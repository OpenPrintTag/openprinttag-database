/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * Generated by: scripts/generate-schema-metadata.ts
 * Generated at: 2026-01-08T23:28:45.203Z
 *
 * This file provides explicit field mappings for enums and entities,
 * eliminating guessing patterns like `item.slug || item.key || item.name`.
 */

export interface EnumMetadata {
  /** The field used as the stored value (e.g., 'name', 'abbreviation', 'code') */
  valueField: string;
  /** The field used for display labels (e.g., 'display_name', 'name') */
  labelField: string;
  /** Optional secondary label field */
  secondaryLabelField?: string;
}

export interface RelationMetadata {
  /** The target entity type */
  entity: string;
  /** The field used as the stored value/reference */
  valueField: string;
  /** The field used for display labels */
  labelField: string;
  /** Whether this is an array relation */
  isArray?: boolean;
}

/**
 * Enum/lookup table metadata with explicit value and label fields.
 */
export const ENUM_METADATA: Record<string, EnumMetadata> = {
  brand_link_pattern_types: {
    valueField: 'name',
    labelField: 'name',
  },
  material_certifications: {
    valueField: 'name',
    labelField: 'display_name',
  },
  material_photo_types: {
    valueField: 'name',
    labelField: 'name',
  },
  material_tag_categories: {
    valueField: 'name',
    labelField: 'display_name',
  },
  material_tags: {
    valueField: 'name',
    labelField: 'display_name',
  },
  material_types: {
    valueField: 'abbreviation',
    labelField: 'name',
    secondaryLabelField: 'abbreviation',
  },
};

/**
 * Entity metadata with explicit primary key and display fields.
 */
export const ENTITY_METADATA: Record<
  string,
  { primaryKey: string; displayField: string }
> = {
  brands: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  brand: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  materials: {
    primaryKey: 'uuid',
    displayField: 'name',
  },
  material: {
    primaryKey: 'uuid',
    displayField: 'name',
  },
  material_containers: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  material_container: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  material_packages: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  material_package: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  containers: {
    primaryKey: 'slug',
    displayField: 'name',
  },
  packages: {
    primaryKey: 'slug',
    displayField: 'name',
  },
};

/**
 * Field-to-enum mapping for known enum fields.
 */
export const FIELD_ENUM_MAP: Record<string, string> = {
  type: 'material_types',
  tags: 'material_tags',
  certifications: 'material_certifications',
  countries_of_origin: 'countries',
  category: 'material_tag_categories',
  photo_type: 'material_photo_types',
};

/**
 * Field-to-relation mapping for known relation fields.
 */
export const FIELD_RELATION_MAP: Record<string, RelationMetadata> = {
  brand: {
    entity: 'brands',
    valueField: 'slug',
    labelField: 'name',
  },
  material: {
    entity: 'materials',
    valueField: 'uuid',
    labelField: 'name',
  },
  container: {
    entity: 'containers',
    valueField: 'slug',
    labelField: 'name',
  },
  package: {
    entity: 'packages',
    valueField: 'uuid',
    labelField: 'name',
  },
};

/**
 * Get enum metadata for a given table name.
 */
export function getEnumMetadata(tableName: string): EnumMetadata | null {
  return ENUM_METADATA[tableName] ?? null;
}

/**
 * Get entity metadata for a given entity name.
 */
export function getEntityMetadata(
  entityName: string,
): { primaryKey: string; displayField: string } | null {
  return (
    ENTITY_METADATA[entityName] ??
    ENTITY_METADATA[entityName.replace(/s$/, '')] ??
    null
  );
}

/**
 * Get the enum table name for a field.
 */
export function getFieldEnumTable(fieldName: string): string | null {
  return FIELD_ENUM_MAP[fieldName] ?? null;
}

/**
 * Get relation metadata for a field.
 */
export function getFieldRelation(fieldName: string): RelationMetadata | null {
  return FIELD_RELATION_MAP[fieldName] ?? null;
}

/**
 * Extract value from an enum item using metadata.
 */
export function extractEnumValue(
  item: Record<string, unknown>,
  tableName: string,
): string {
  const meta = getEnumMetadata(tableName);
  if (!meta) {
    // Fallback for unknown enums - should not happen if metadata is complete
    console.warn(`Unknown enum table: ${tableName}`);
    return String(item.name ?? item.key ?? item.id ?? '');
  }
  return String(item[meta.valueField] ?? '');
}

/**
 * Extract label from an enum item using metadata.
 */
export function extractEnumLabel(
  item: Record<string, unknown>,
  tableName: string,
): string {
  const meta = getEnumMetadata(tableName);
  if (!meta) {
    console.warn(`Unknown enum table: ${tableName}`);
    return String(item.display_name ?? item.name ?? item.key ?? '');
  }
  return String(item[meta.labelField] ?? item[meta.valueField] ?? '');
}

/**
 * Extract value from an entity using metadata.
 */
export function extractEntityValue(
  item: Record<string, unknown>,
  entityName: string,
): string {
  const meta = getEntityMetadata(entityName);
  if (!meta) {
    console.warn(`Unknown entity: ${entityName}`);
    return String(item.slug ?? item.uuid ?? item.id ?? '');
  }
  return String(item[meta.primaryKey] ?? '');
}

/**
 * Extract label from an entity using metadata.
 */
export function extractEntityLabel(
  item: Record<string, unknown>,
  entityName: string,
): string {
  const meta = getEntityMetadata(entityName);
  if (!meta) {
    console.warn(`Unknown entity: ${entityName}`);
    return String(item.name ?? item.display_name ?? '');
  }
  return String(item[meta.displayField] ?? item[meta.primaryKey] ?? '');
}

/**
 * Convert enum items to options array.
 */
export function enumToOptions(
  items: Record<string, unknown>[],
  tableName: string,
): Array<{ value: string; label: string }> {
  return items.map((item) => ({
    value: extractEnumValue(item, tableName),
    label: extractEnumLabel(item, tableName),
  }));
}

/**
 * Convert entity items to options array.
 */
export function entityToOptions(
  items: Record<string, unknown>[],
  entityName: string,
): Array<{ value: string; label: string }> {
  return items.map((item) => ({
    value: extractEntityValue(item, entityName),
    label: extractEntityLabel(item, entityName),
  }));
}
